
; Метки объявленные с директивой global являются глобальными.
; Глобальные метки нужны она для возможности написания многомодульных программ.
; Благодаря ним другие модули могут, ссылаясь на эту метку,
; исполнять строки кода из данного модуля (стр. 17).
; В данном случае мы объявляем метку "_start" как глобальную.
; Это необходимо, чтобы компилятор знал, где начинается программа.
global _start

; Секция статических данных (известных во время компиляции).
; В ней будут находить все данные известные до запуска программы,
; т.е. которые не будут изменяться во время работы программы.
; (подробнее стр. 9).
section .data

; const_filename_plaintext содержит имя файла, из которого 
; будет происходить считывание открытого текста (подробнее о db на стр. 7).
const_filename_plaintext db 'plaintext.txt', 0

; const_filename_encryptedtext содержит имя файла, в который 
; будет происходить запись шифртекста.
const_filename_encryptedtext db 'encryptedtext.txt', 0

; const_filename_decryptedtext содержит имя файла, в который 
; будет происходить запись расшифрованного текста.
const_filename_decryptedtext db 'decryptedtext.txt', 0

; const_message_for_user - сообщение пользователю, предлагающее ввести пароль
; число 10 обозначает переход на новую строку
const_message_for_user db 'Enter key (up to 20 symbols):', 10

; const_len_message_for_user - хранит длинну сообщения для пользователя
; $ - равен текущему адресу
const_len_message_for_user equ $ - const_message_for_user

const_asterisk db '*'

ICANON db 2
ECHO db 8


; Секция динамических данных (так называемая куча).
; В ней будут находить все переменные, используемые и определяемые
; во время работы программы (подробнее стр. 9).
section .bss

termios resb 36

; val_buffer - переменная, указывающая на буфер для обработки данных.
; Принцип работы программы следующий:
; 1) Считываем до 4096 байтов текста из файла 'plaintext.txt'
;    в буфер val_buffer.
; 2) Шифруем текст в буфере.
; 3) Записываем шифртекст из буфера в файл 'encryptedtext.txt'.
; 4) Если на 1 шаге дошли до конца файла, то конец программы,
;    иначе возвращаемся к 1 шагу.
val_buffer resb 4096

; val_key - хранит ключ, максимальная длина которого - 20 байт, минимальная допустимая - 1
val_key resb 21
val_len_key resb 4

; val_tmp - временный буфер, в него, например, будем сохранять 
; по одному символу при вводе пароля
val_tmp resb 2

; val_ptr_file_plaintext - хранит указатель на файл с открытыми данными
val_ptr_file_plaintext resb 4

; val_ptr_file_encryptedtext - хранит указатель на файл с зашифрованными данными
val_ptr_file_encryptedtext resb 4

; val_ptr_file_decryptedtext - хранит указатель на файл с расшифрованными данными
val_ptr_file_decryptedtext resb 4


section .text

; Начало программы
_start:

; открытие файла с открытым текстом в режиме чтения

; создание и открытие файла с зашифрованным текстом в режиме записи

; считывание ключа
call _read_key

; чтение открытого тектса, его зашифрование и 
; запись зашифрованного текста в соответсвующий файл

jmp _end






; ------------------------------------------------------------------------------
; Функция, отвечающая за считывание ключа из командной строки
; Не принимает аргументов
; В случае успешного чтения ключа он будет записан в val_key, а в val_len_key его длинна
_read_key:

    ; Вывод сообщения пользователю
    ; Подробнее о том как работают функции считывания и записи в файл на стр. 10
    ; 4 - обозначает функцию записи
    ; ssize_t write(int fd, const void *buf, size_t count)
    mov eax, 4

    ; В регистр ebx нужно положить первый аргумент для функции write - "int fd",
    ; а именно указатель на файл записи. В данном случае 1, т.к. это
    ; указывает на то, что запись будет будет производиться на дисплей
    mov ebx, 1

    ; В регистр ecx кладем второй аргумент - буфер данных для записи
    mov ecx, const_message_for_user

    ; В edx кладем третий аргумент - количество записываемых символов
    mov edx, const_len_message_for_user

    ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
    int 0x80

    ; Если при вызове функции произошла ошибка,
    ; то в регистре eax будет отрицательное число.
    ; Для проверки eax используем функцию test (подробнее стр. 8)
    test eax, eax
    
    ; Если в eax появилось отрицательное число, то функция test установит 
    ; флаг sf в 1, и тогда сработает условный переход js, и программа 
    ; перейдет в блок обработки ошибки считывания ключа _error_read_key
    ; (подробнее об условных переходах стр. 4).
    js _error_read_key


    call _turn_canonical_echo_off
    
    ; обнуляем региср esi, он будет служить для хранения количества
    ; уже введеных пользователем символов
    xor esi, esi

    ; цикл для считывания пароля
    _loop_key_read:

        ; если количество введеных символов станет больше 20,
        ; значит пользователь превысил максимальную длину пароля
        cmp esi, 20
        ja _error_read_key_len

        ; Считывание пароля, будем считывать по 1 символу и 
        ; выводить звездочку на каждый символ
        ; 3 - обозначает функцию считывания
        ; ssize_t read(int fd, void *buf, size_t count)
        mov eax, 3
        
        ; В регистр ebx нужно положить первый аргумент для функции read - "int fd",
        ; а именно указатель на файл считывания. В данном случае 0, т.к. это
        ; указывает на то, что считывание будет происходить с клавиатруры
        mov ebx, 0
        
        ; В регистр ecx кладем второй аргумент - буфер для считанных данных
        mov ecx, val_tmp
        
        ; В edx кладем третий аргумент - количество считываемых символов
        mov edx, 1
        
        ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
        int 80h
        
        test eax, eax
        js _error_read_key

        mov al, byte [val_tmp]
        ; проверка того, что пользователь ввел Enter (символ перехода на новую строку)
        cmp al, 10
        je _end_loop_key_read
        
        ; ; Если в eax появился 0, значит пользователь не ввел ни одного 
        ; ; символа и нажал Enter. В таком случае тоже переходим в блок ошибки.
        ; ; Для проверки на ноль используем функцию cmp (стр. 4)
        ; cmp eax, 0
        ; jz _error_read_key

        ; если пользователь ввел не Enter, то записываем символ в буфер
        mov byte [val_key + esi], al

        ; Вывод звездочки на экран
        mov eax, 4
        mov ebx, 1
        mov ecx, const_asterisk
        mov edx, 1
        int 80h

        ; ошибка при выводе звездочки
        test eax, eax
        js _error_read_key

        ; увеличиваем текущую длинну пароля
        inc esi

        jmp _loop_key_read

    ; конец цикла считывания ключа
    _end_loop_key_read:

    ; проверка на то, что пользователь не ввел ни одного символа и нажал Enter
    cmp esi, 0
    je _error_read_key_len

    ; сохраняем длинну ключа в переменную val_len_key
    mov dword [val_len_key], esi

    call _turn_canonical_echo_on

    ret

; ------------------------------------------------------------------------------







; ------------------------------------------------------------------------------
; Функция, отвечающая за открытие файла,
; принимает три аргумента 
;   через ebx - название файла,
;   через ecx - режим открытия файла
;   через edx - права на доступ к файлу
; возвращает один аргумент через eax - указатель на открытый файл
_open_file:
    ; 5 - обозначает функцию открытия файла (стр. 10)
    ; int open(const char *pathname, int flags)
    ; или
    ; int open(const char *pathname, int flags, mode__t mode)
    mov eax, 5
    
    ; Вызываем указанную функцию с указанными параметрами
    int 80h
    
    ; Проверяем, что функция open отработала без ошибки,
    ; т.е. проверяем положительное или отрицательное число лежит в eax
    test eax, eax
    
    ; Если в eax появилось отрицательное число, то сработает
    ; условный переход js, и программа перейдет в блок 
    ; обработки ошибки открытия файла с текстом _error_open_file
    js _error_open_file
    
    ret
; ------------------------------------------------------------------------------







; ------------------------------------------------------------------------------
; Функция шифрования текта. Общий принцип работы следующий:
; 1) Считывание до 4096 байтов из файла val_ptr_file_plaintext с открытым текстом в буфер val_buffer
; 2) Шифрование данных в буфере val_buffer ключем из val_key
; 3) Запись зашифрованных данных в файл val_ptr_file_encryptedtext
; 4) Если остались несчитанные данные в файле val_ptr_file_plaintext, возврат к пункту 1
_encrypt_text:

    
; ------------------------------------------------------------------------------


; Блок кода, отвечающий за запись шифр-текста в файл ""
_write_encrypted_text:

; Блок кода, отвечающий за обработку ошибки при неправильной длинне ключа
_error_read_key_len:

; Блок кода, отвечающий за обработку любых других ошибок при считывании ключа
_error_read_key:

; Блок кода, отвечающий за обработку ошибки открытия файла (любого)
_error_open_file:



; ------------------------------------------------------------------------------
; Блок отвечающий за красивый ввод пароля, благодаря этому блоку
; при вводе пароля не будут видны символы, из которых он состоит,
; и вместо них будут выводиться звездочки.
; 
; Чтобы понять, как это происходит, нужно вспомнить, как делаются системные вызовы (стр. 6).
; Для того чтобы вызвать системную функцию (т.е. сделать системный вызов),
; мы должны сделать вызов ядра, при этом в регистре eax указать номер системного вызова
; (т.е. номер системной функции). 
; Напомню, ядро вызывается с помощью прерывания номер 80h (int 80h).
; Мы уже и раньше вызывали системные функции (например, 5 - для открытия файла и др.)
; 
; Теперь ближе к сути. По умолчанию, когда мы работаем в терминале, 
; он работает в так называемом каноническом режиме и еще в эхо-режиме.
; Канонический режим - значит, что данные, которые мы вводим во время работы в терминале, 
; не будут считаны до тех пор, пока не будет введена клавиша Enter. Это представляет проблему 
; при считывании пароля, т.к. мы бы хотели сразу же считывать введеный пользователем символ.
; Это помогло бы нам записывать вновь введеный пользователем символ в подготовленный буфер памяти и
; одновременно считать количество введенных пользователем символов, увеличивая длинну на 1 
; при вводе нового символа. 
; 
; Если бы мы попытались реализовать такую логику в каноническом режиме, то нам пришлось бы заставлять
; пользователя нажимать Enter каждый раз после ввода нового символа пароля, потому что, повторюсь,
; в каноническом режиме введеные символы не будут считаны до тех пор по не нажата клавиша Enter.
; А, соответственно, в неканоническом режиме символы считываются терминалом сразу же после их ввода,
; т.е. после нажатия на соответствующую клавишу, без необходимости нажимать после этого Enter.
; 
; Эхо-режим - такой режим, когда введенный пользователем сивол сразу же отображается на экране.
; Т.е., например, вы вводите 2, и на экране в тот же момент отображается 2.
; А мы хотим, чтобы вы вводили 2, а на экране ничего не появлялось, но на самом деле эта 2 должна также нормально 
; считаться терминалом, как и при эхо-режиме, вопрос только в отображении на экран. Почему при вводе 
; пароля это будет полезно, потому что вводимые символы не будут отображаться (это типо безопасно),
; а еще потому что в связке с неканоническим режимом при мгновенном считывании вводимых символов 
; (т.е. без необходимости нажимать Enter для каждого символа) мы в тот же момент можем выводить на экран, 
; например, звездочки вместо каждого введенного символа.
; 
; Именно поэтому мы и хотим отключить оба этих режима,
; НО ТОЛЬКО НА ВРЕМЯ ВВОДА ПАРОЛЯ.
; Т.е. после этого мы должны обратно включить оба этих режима,
; просто потому что так принято, что терминал по умолчанию работает в таких режимах. 
; 
; Теперь техническая часть вопроса. Вернемся к системным вызовам.
; Для настройки, в том числе, режимов работы термина используется системный вызов 
; (т.е. системная функция) 36h (ioctl - подробнее в инете).
; Эта функция принимает три аргумента:
; 1) файл, с которым работаем, в данном случае = 0, обозначающий стандартный поток ввода в терминале (STDIN);
; 2) число, обозначающее, что мы хотим сделать, в данном случае будем использовать всего два числа: 
;    5041h - для того, чтобы получить текущие настройки терминала и 5042h - для того, чтобы задать новые настройки;
; 3) указатель на область памяти, которая хранит структуру, которая будет содержать настройки терминала, 
;    ее размер 36 байт. Если мы задали второй аргумент = 5041h, то после вызова системной функции текущие настройки
;    терминала скопируются в эту область памяти. Если же задали 5042h, то после вызова системной функции, настройки
;    из этой области памяти скопируются и заменят собой текущие настройки терминала.
; 
; Структура выглядит так:
; struct termios {
;     tcflag_t c_iflag;               /* input mode flags */
;     tcflag_t c_oflag;               /* output mode flags */
;     tcflag_t c_cflag;               /* control mode flags */
;     tcflag_t c_lflag;               /* local mode flags */
;     cc_t     c_line;                /* line discipline */
;     cc_t     c_cc[NCCS];            /* control characters */
; };
; 
; Здесь тип tcflag_t - 4 байта, cc_t - 1 байт, NCCS=19. Итого 36 байт занимает 
; вся структура настроек терминала, называемая termios.
; 
; Нас интересует переменая c_lflag. Т.к. все переменные в структуре фактически 
; располагаются в памяти друг за другом, то c_lflag начинается с 12 байта (если вести отсчет с нуля).
; 
; В самом c_lflag за канонический режим отвечает первый бит 
; (если вести отсчет с нуля, давайте считать что дальше вездем ведем так отсчет),
; а за эхо-режим третий бит.
; 
; Т.е. вся суть работы сводится к:
; 1) мы получаем текущие настройки терминала (5041h);
; 2) меняем первый и третий биты четвертого байта структуры termios на нолики;
; 3) загружаем новые настройки (5042h);
; 4) вводим пароль;
; 5) снова получаем текущие настройки терминала (5041h);
; 6) меняем первый и третий биты четвертого байта структуры termios на единички, 
;    чтобы обратно включить канонический и эхо режимы.
; 

_turn_canonical_echo_off:
    call _read_stdin_termios
    mov eax, ICANON
    or eax, ECHO
    not eax
    and [termios + 12], eax
    call _write_stdin_termios
    ret
    

_turn_canonical_echo_on:
    call _read_stdin_termios
    mov eax, ICANON
    or eax, ECHO
    or [termios + 12], eax
    call _write_stdin_termios
    ret


_read_stdin_termios:
    mov eax, 36h
    mov ebx, 0
    mov ecx, 5401h
    mov edx, termios
    int 80h
    ret

_write_stdin_termios:
    mov eax, 36h
    mov ebx, 0
    mov ecx, 5402h
    mov edx, termios
    int 80h
    ret

; ------------------------------------------------------------------------------


_end:
    mov eax, 1
    mov ebx, 0
    int 80h
