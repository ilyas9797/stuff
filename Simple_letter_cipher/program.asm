
; Метки объявленные с директивой global являются глобальными.
; Глобальные метки нужны она для возможности написания многомодульных программ.
; Благодаря ним другие модули могут, ссылаясь на эту метку,
; исполнять строки кода из данного модуля (стр. 17).
; В данном случае мы объявляем метку "_start" как глобальную.
; Это необходимо, чтобы компилятор знал, где начинается программа.
; global _start
global _read_key
global _encrypt_text
global _decrypt_text



















; ------------------------------------------------------------------------------
; Секция статических данных (известных во время компиляции).
; В ней будут находить все данные известные до запуска программы,
; т.е. которые не будут изменяться во время работы программы.
; (подробнее стр. 9).
section .data

; const_filename_plaintext содержит имя файла, из которого 
; будет происходить считывание открытого текста (подробнее о db на стр. 7).
const_filename_plaintext db 'plaintext.txt', 0

; const_filename_encryptedtext содержит имя файла, в который 
; будет происходить запись шифртекста.
const_filename_encryptedtext db 'encryptedtext.txt', 0

; const_filename_decryptedtext содержит имя файла, в который 
; будет происходить запись расшифрованного текста.
const_filename_decryptedtext db 'decryptedtext.txt', 0

; const_message_for_user - сообщение пользователю, предлагающее ввести пароль
; число 10 обозначает переход на новую строку
const_message_for_user db 'Enter key (up to 20 symbols):', 10

; const_len_message_for_user - хранит длинну сообщения для пользователя
; $ - равен текущему адресу
const_len_message_for_user equ $ - const_message_for_user

const_asterisk db '*'

ICANON equ 1<<1
ECHO equ 1<<3
; ------------------------------------------------------------------------------




























; ------------------------------------------------------------------------------
; Секция динамических данных (так называемая куча).
; В ней будут находить все переменные, используемые и определяемые
; во время работы программы (подробнее стр. 9).
section .bss

termios resb 36

; val_buffer - переменная, указывающая на буфер для обработки данных.
; Принцип работы программы следующий:
; 1) Считываем до 4096 байтов текста из файла 'plaintext.txt'
;    в буфер val_buffer.
; 2) Шифруем текст в буфере.
; 3) Записываем шифртекст из буфера в файл 'encryptedtext.txt'.
; 4) Если на 1 шаге дошли до конца файла, то конец программы,
;    иначе возвращаемся к 1 шагу.
val_buffer resb 4096

; val_key - хранит ключ, максимальная длина которого - 20 байт, минимальная допустимая - 1
val_key resb 21
val_len_key resb 4

; val_tmp - временный буфер, в него, например, будем сохранять 
; по одному символу при вводе пароля
val_tmp resb 2

; val_ptr_file_plaintext - хранит указатель на файл с открытыми данными
val_ptr_file_plaintext resb 4

; val_ptr_file_encryptedtext - хранит указатель на файл с зашифрованными данными
val_ptr_file_encryptedtext resb 4

; val_ptr_file_decryptedtext - хранит указатель на файл с расшифрованными данными
val_ptr_file_decryptedtext resb 4
; ------------------------------------------------------------------------------

























; ------------------------------------------------------------------------------
section .text

; Начало программы
_start:

; открытие файла с открытым текстом в режиме чтения

; создание и открытие файла с зашифрованным текстом в режиме записи

; считывание ключа
call _read_key

; чтение открытого тектса, его зашифрование и 
; запись зашифрованного текста в соответсвующий файл
call _encrypt_text

call _decrypt_text

jmp _end



; ------------------------------------------------------------------------------
; Функция, отвечающая за считывание ключа из командной строки
; Не принимает аргументов
; В случае успешного чтения ключа он будет записан в val_key, а в val_len_key его длинна
_read_key:


    ; Вывод сообщения пользователю
    ; Подробнее о том как работают функции считывания и записи в файл на стр. 10
    ; 4 - обозначает функцию записи
    ; ssize_t write(int fd, const void *buf, size_t count)
    mov eax, 4

    ; В регистр ebx нужно положить первый аргумент для функции write - "int fd",
    ; а именно указатель на файл записи. В данном случае 1, т.к. это
    ; указывает на то, что запись будет будет производиться на дисплей
    mov ebx, 1

    ; В регистр ecx кладем второй аргумент - буфер данных для записи
    mov ecx, const_message_for_user

    ; В edx кладем третий аргумент - количество записываемых символов
    mov edx, const_len_message_for_user

    ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
    int 0x80

    ; Если при вызове функции произошла ошибка,
    ; то в регистре eax будет отрицательное число.
    ; Для проверки eax используем функцию test (подробнее стр. 8)
    test eax, eax
    
    ; Если в eax появилось отрицательное число, то функция test установит 
    ; флаг sf в 1, и тогда сработает условный переход js, и программа 
    ; перейдет в блок обработки ошибки считывания ключа _error_read_key
    ; (подробнее об условных переходах стр. 4).
    js _error_read_key

    call _turn_canonical_echo_off
    
    ; обнуляем региср esi, он будет служить для хранения количества
    ; уже введеных пользователем символов
    xor esi, esi

    ; цикл для считывания пароля
    _loop_read_key:

        ; если количество введеных символов станет больше 20,
        ; значит пользователь превысил максимальную длину пароля
        cmp esi, 20
        ja _error_read_key_len

        ; Считывание пароля, будем считывать по 1 символу и 
        ; выводить звездочку на каждый символ
        ; 3 - обозначает функцию считывания
        ; ssize_t read(int fd, void *buf, size_t count)
        mov eax, 3
        
        ; В регистр ebx нужно положить первый аргумент для функции read - "int fd",
        ; а именно указатель на файл считывания. В данном случае 0, т.к. это
        ; указывает на то, что считывание будет происходить с клавиатруры
        mov ebx, 0
        
        ; В регистр ecx кладем второй аргумент - буфер для считанных данных
        mov ecx, val_tmp
        
        ; В edx кладем третий аргумент - количество считываемых символов
        mov edx, 1
        
        ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
        int 80h
        
        test eax, eax
        js _error_read_key

        mov al, byte [val_tmp]
        ; проверка того, что пользователь ввел Enter (символ перехода на новую строку)
        cmp al, 10
        je _end_loop_read_key

        ; если пользователь ввел не Enter, то записываем символ в буфер,
        ; причем записываем вес символа, т.е для буквы a (A) - это 1, для b (B) - это 2 и т.д.
        ; Также нужно проверить, что введена именно буква
        ; является ли текущий символ маленькой буквой
        ; 97 <= al <= 122
        cmp al, 97
        jb _read_key_check_next
        cmp al, 122
        ja _read_key_check_next
        sub al, 97
        jmp _read_key_check_end


        _read_key_check_next:
        ; является ли текущий символ большой буквой
        ; 65 <= al <= 90
        cmp al, 65
        jb _error_read_key_wrong_symbol
        cmp al, 90
        ja _error_read_key_wrong_symbol
        sub al, 65

        _read_key_check_end:

        mov byte [val_key + esi], al

        ; Вывод звездочки на экран
        mov eax, 4
        mov ebx, 1
        mov ecx, const_asterisk
        mov edx, 1
        int 80h

        ; ошибка при выводе звездочки
        test eax, eax
        js _error_read_key

        ; увеличиваем текущую длинну пароля
        inc esi

        jmp _loop_read_key

    ; конец цикла считывания ключа
    _end_loop_read_key:

    ; проверка на то, что пользователь не ввел ни одного символа и нажал Enter
    cmp esi, 0
    je _error_read_key_len

    ; сохраняем длинну ключа в переменную val_len_key
    mov dword [val_len_key], esi

    call _turn_canonical_echo_on

    ret

; ------------------------------------------------------------------------------























; ------------------------------------------------------------------------------
; Функция шифрования текта. Общий принцип работы следующий:
; 1) Считывание до 4096 байтов из файла const_filename_plaintext с открытым текстом в буфер val_buffer
; 2) Шифрование данных в буфере val_buffer ключем из val_key
; 3) Запись зашифрованных данных в файл const_filename_encryptedtext
; 4) Если остались несчитанные данные в файле const_filename_plaintext, возврат к пункту 1
_encrypt_text:

    ; открытие файла c открытым текстом с именем const_filename_plaintext в режиме чтения
    mov eax, 5
    mov ebx, const_filename_plaintext
    mov ecx, 0
    int 80h
    test eax, eax
    js _error_open_file

    ; сохраняем дескриптор файла c открытым текстом
    mov dword [val_ptr_file_plaintext], eax

    ; открытие файла c зашифрованным текстом с именем const_filename_encryptedtext в режиме создания и записи
    mov eax, 5
    mov ebx, const_filename_encryptedtext
    mov ecx, 101q
    mov edx, 700q
    int 80h
    test eax, eax
    js _error_open_file

    ; сохраняем дескриптор файла c зашифрованным текстом
    mov dword [val_ptr_file_encryptedtext], eax

    ; будем используем для хранения текущего символа ключа
    xor esi, esi


    ; цикл, для считывания файла с открытым текстом порционно по 4096 байтов
    _loop_read_plaintext_file:

        ; чтение до 4096 байтов из файла с открытым текстом 
        mov eax, 3
        mov ebx, dword [val_ptr_file_plaintext]
        mov ecx, val_buffer
        mov edx, 4096
        int 80h

        ; Проверяем, что функция read отработала без ошибки,
        ; т.е. проверяем положительное или отрицательное число лежит в eax
        test eax, eax
        js _error_read_file

        ; если не было считано ни одного символа, значит достигли конца файла, и выходим из цикла
        cmp eax, 0
        je _end_loop_read_plaintext_file

        ; используем команду loop и регистр ecx для организации цикла (подробнее стр. 5)
        ; eax будет также хранить ориинальное количество считанных символов
        mov ecx, eax

        ; цикл, который зашифровывает побайтово буфер со считанным текстом val_buffer согласно следующему правилу:
        ; 1) если символ - буква (неважно какой регистр) или цифра то шифруем (типо с учетом весов)
        ; 2) иначе пропускаем, причем в этом случае не переходим к следующему символу ключа
        ; В цикле нельзя использовать регистр ecx - отвечает за работу цикла (подробнее стр. 5),
        ; eax - будет хранит длинну считанного текста (можно сохранять перед использованием, а потом восстановливать)
        _loop_encrypt_buffer:

            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ; определяем текущий символ ключа по формуле
            ; esi % val_len_key
            
            ; сохраним значение eax, чтобы не потерять длину считанного блока
            push eax

            ; вычислим номер символа ключа, с помощью которого шифруется текущий символ текста
            ; при взятии значения регистра esi по модулю val_len_key будем рассматривать 
            ; только младшую часть регистра esi, т.е. si, потому что, напомню, максимальная длина
            ; ключа может быть 20 символов и это значение будет занимать точно меньше 16 бит, 
            ; поэтому, очевидно, что будет умещаться в младшей половине регистра esi (напомню, 
            ; длина регистра esi - 32 бита)
            ; можно не волноваться за переполнение ax и bx,
            ; т.к. максимальная длина ключа точно меньше 16 бит
            mov ax, si
            mov bx, word [val_len_key]
            call _do_mod
            mov si, ax

            ; восстановим значение eax
            pop eax
            ; определили текущий символ ключа
            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ; начало шифрования
            ; проверка что символ - буква
            ; а иначе пропуск блока шифрования

            ; сохраним eax, напомню, в котором хранится кол-во считанных из файла символов
            push eax

            xor edx, edx
            ; переместим рассматриваемый символ (байт) в bl
            
            xor ebx, ebx
            xor edi, edi
            mov di, ax
            sub di, cx
            mov bl, byte [val_buffer + edi]
            
            ; является ли текущий символ маленькой буквой
            ; 97 <= bx <= 122
            cmp bl, 97
            jb _check_enc_next
            cmp bl, 122
            ja _check_enc_next
            mov dl, byte [val_key + esi]
            mov al, 97
            call _do_encrypt
            ; Только в случае если предыдущий символ был буквой переходим к следующему символу ключа
            inc esi
            jmp _check_enc_end



            _check_enc_next:
            ; является ли текущий символ большой буквой
            ; 65 <= bx <= 90
            cmp bl, 65
            jb _check_enc_end
            cmp bl, 90
            ja _check_enc_end
            mov dl, byte [val_key + esi]
            mov al, 65
            call _do_encrypt
            ; Только в случае если предыдущий символ был буквой переходим к следующему символу ключа
            inc esi

            _check_enc_end:

            ; восстановим eax, напомню, в котором должно хранится кол-во считанных из файла символов
            pop eax
            ; конец шифрования
            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            ; теперь в bl лежит зашифрованный символ (ну или незашифрованный, 
            ; а тот же самый, если символ не был буквой)
            ; перезапишем его в буфер
            xor edi, edi
            mov di, ax
            sub di, cx
            mov byte [val_buffer + edi], bl
            
            ; Это как раз тот самый неверный переход к следующему символа ключа,
            ; даже если предыдущий смивол не был буквой
            ; ; возьмем следующий символ ключа
            ; inc esi

        loop _loop_encrypt_buffer

        ; теперь в буфере храниться зашифрованное сообщение
        ; запишем его в файл с зашифрованным сообщением const_filename_encryptedtext
        push eax
        ; количество зашифрованных символов
        mov edx, eax
        ; операция записи
        mov eax, 4
        ; дескриптор файла с зашифрованным текстом
        mov ebx, dword [val_ptr_file_encryptedtext]
        ; указатель на буфер с зашифрованным текстом
        mov ecx, val_buffer
        int 80h
        test eax, eax
        js _error_write_file

        pop eax
        


        ; если на этой итерации цикла мы считали 4096 байтов текста,
        ; значит, возможно в файле остались еще несчитанные символы
        cmp eax, 4096
        je _loop_read_plaintext_file

        

    _end_loop_read_plaintext_file:

    ; закончили работать с файлами, теперь их можно закрыть
    mov eax, 6
    mov ebx, dword [val_ptr_file_encryptedtext]
    int 80h

    mov eax, 6
    mov ebx, dword [val_ptr_file_plaintext]
    int 80h
    

    ret
; ------------------------------------------------------------------------------












; ------------------------------------------------------------------------------
; Функция шифрует символ текста символом ключа
; перед вызовом функции сохранить значения EAX, EBX, EDX
; Входные аргументы:
; BL - шифруемый символ
; DL - вес символа ключа
; AL - смещение в таблице ascii
; Возвращаемое значение:
; BL - зашифрованный символ
_do_encrypt:


    ; вычисляем вес символа текста
    sub bl, al
    
    ; складываем символ текста с символом ключа
    add bl, dl

    push eax
    ; возьмем сложенное значение по модулю 26, именно столько букв в англ алфавите
    mov ax, bx
    mov bx, 26
    call _do_mod

    ; вернем полученное значение в BL
    mov bl, al
    pop eax
    add bl, al

    ret
; ------------------------------------------------------------------------------

















; ------------------------------------------------------------------------------
; Функция расшифрования текта. Общий принцип работы следующий:
; 1) Считывание до 4096 байтов из файла const_filename_encryptedtext с зашифрованным текстом в буфер val_buffer
; 2) Расшифрование данных в буфере val_buffer ключем из val_key
; 3) Запись расшифрованных данных в файл const_filename_decryptedtext
; 4) Если остались несчитанные данные в файле const_filename_encryptedtext, возврат к пункту 1
_decrypt_text:

    ; открытие файла c зашифрованным текстом с именем const_filename_encryptedtext в режиме чтения
    mov eax, 5
    mov ebx, const_filename_encryptedtext
    mov ecx, 0
    int 80h
    test eax, eax
    js _error_open_file

    ; сохраняем дескриптор файла c зашифрованным текстом
    mov dword [val_ptr_file_encryptedtext], eax

    ; открытие файла c расшифрованным текстом с именем const_filename_decryptedtext в режиме создания и записи
    mov eax, 5
    mov ebx, const_filename_decryptedtext
    mov ecx, 101q
    mov edx, 700q
    int 80h
    test eax, eax
    js _error_open_file

    ; сохраняем дескриптор файла c расшифрованным текстом
    mov dword [val_ptr_file_decryptedtext], eax

    ; будем используем для хранения текущего символа ключа
    xor esi, esi


    ; цикл, для считывания файла с зашифрованным текстом порционно по 4096 байтов
    _loop_read_encryptedtext_file:

        ; чтение до 4096 байтов из файла с зашифрованным текстом 
        mov eax, 3
        mov ebx, dword [val_ptr_file_encryptedtext]
        mov ecx, val_buffer
        mov edx, 4096
        int 80h

        ; Проверяем, что функция read отработала без ошибки,
        ; т.е. проверяем положительное или отрицательное число лежит в eax
        test eax, eax
        js _error_read_file

        ; если не было считано ни одного символа, значит достигли конца файла, и выходим из цикла
        cmp eax, 0
        je _end_loop_read_encryptedtext_file

        ; используем команду loop и регистр ecx для организации цикла (подробнее стр. 5)
        ; eax будет также хранить ориинальное количество считанных символов
        mov ecx, eax

        ; цикл, который расшифровывает побайтово буфер со считанным текстом val_buffer согласно следующему правилу:
        ; 1) если символ - буква (неважно какой регистр) или цифра то расшифруем (типо с учетом весов)
        ; 2) иначе пропускаем, причем в этом случае не переходим к следующему символу ключа
        ; В цикле нельзя использовать регистр ecx - отвечает за работу цикла (подробнее стр. 5),
        ; eax - будет хранит длинну считанного текста (можно сохранять перед использованием, а потом восстановливать)
        _loop_decrypt_buffer:

            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ; определяем текущий символ ключа по формуле
            ; esi % val_len_key
            
            ; сохраним значение eax, чтобы не потерять длину считанного блока
            push eax

            ; вычислим номер символа ключа, с помощью которого расшифруется текущий символ текста
            ; при взятии значения регистра esi по модулю val_len_key будем рассматривать 
            ; только младшую часть регистра esi, т.е. si, потому что, напомню, максимальная длина
            ; ключа может быть 20 символов и это значение будет занимать точно меньше 16 бит, 
            ; поэтому, очевидно, что будет умещаться в младшей половине регистра esi (напомню, 
            ; длина регистра esi - 32 бита)
            ; можно не волноваться за переполнение ax и bx,
            ; т.к. максимальная длина ключа точно меньше 16 бит
            mov ax, si
            mov bx, word [val_len_key]
            call _do_mod
            mov si, ax

            ; восстановим значение eax
            pop eax
            ; определили текущий символ ключа
            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ; начало расшифрования
            ; проверка что символ - буква
            ; а иначе пропуск блока расшифрования

            ; сохраним eax, напомню, в котором хранится кол-во считанных из файла символов
            push eax

            xor edx, edx
            ; переместим рассматриваемый символ (байт) в bl
            
            xor ebx, ebx
            xor edi, edi
            mov di, ax
            sub di, cx
            mov bl, byte [val_buffer + edi]
            
            ; является ли текущий символ маленькой буквой
            ; 97 <= bx <= 122
            cmp bl, 97
            jb _check_dec_next
            cmp bl, 122
            ja _check_dec_next
            mov dl, byte [val_key + esi]
            mov al, 97
            call _do_decrypt
            ; Только в случае если предыдущий символ был буквой переходим к следующему символу ключа
            inc esi
            jmp _check_dec_end



            _check_dec_next:
            ; является ли текущий символ большой буквой
            ; 65 <= bx <= 90
            cmp bl, 65
            jb _check_dec_end
            cmp bl, 90
            ja _check_dec_end
            mov dl, byte [val_key + esi]
            mov al, 65
            call _do_decrypt
            ; Только в случае если предыдущий символ был буквой переходим к следующему символу ключа
            inc esi

            _check_dec_end:

            ; восстановим eax, напомню, в котором должно хранится кол-во считанных из файла символов
            pop eax
            ; конец расшифрования
            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            ; теперь в bl лежит расшифрованный символ (ну или нерасшифрованный, 
            ; а тот же самый, если символ не был буквой)
            ; перезапишем его в буфер
            xor edi, edi
            mov di, ax
            sub di, cx
            mov byte [val_buffer + edi], bl
            
            ; Это как раз тот самый неверный переход к следующему символа ключа,
            ; даже если предыдущий смивол не был буквой
            ; ; возьмем следующий символ ключа
            ; inc esi

        loop _loop_decrypt_buffer

        ; теперь в буфере храниться расшифрованное сообщение
        ; запишем его в файл с расшифрованным сообщением const_filename_decryptedtext
        push eax
        ; количество зашифрованных символов
        mov edx, eax
        ; операция записи
        mov eax, 4
        ; дескриптор файла с расшифрованным текстом
        mov ebx, dword [val_ptr_file_decryptedtext]
        ; указатель на буфер с расшифрованным текстом
        mov ecx, val_buffer
        int 80h
        test eax, eax
        js _error_write_file

        pop eax
        


        ; если на этой итерации цикла мы считали 4096 байтов текста,
        ; значит, возможно в файле остались еще несчитанные символы
        cmp eax, 4096
        je _loop_read_encryptedtext_file

        

    _end_loop_read_encryptedtext_file:

    ; закончили работать с файлами, теперь их можно закрыть
    mov eax, 6
    mov ebx, dword [val_ptr_file_decryptedtext]
    int 80h

    mov eax, 6
    mov ebx, dword [val_ptr_file_encryptedtext]
    int 80h
    

    ret
; ------------------------------------------------------------------------------













; ------------------------------------------------------------------------------
; Функция расшифрует символ текста символом ключа
; перед вызовом функции сохранить значения EAX, EBX, EDX
; Входные аргументы:
; BL - расшифруемый символ
; DL - вес символа ключа
; AL - смещение в таблице ascii
; Возвращаемое значение:
; BL - зашифрованный символ
_do_decrypt:


    ; вычисляем вес символа текста
    sub bl, al

    add bl, 26
    
    ; вычитаем из символа текста символ ключа
    sub bl, dl

    push eax
    ; возьмем сложенное значение по модулю 26, именно столько букв в англ алфавите
    mov ax, bx
    mov bx, 26
    call _do_mod

    ; вернем полученное значение в BL
    mov bl, al
    pop eax
    add bl, al

    ret
; ------------------------------------------------------------------------------














; ------------------------------------------------------------------------------
; Функция взятие числа по модулю
; перед вызовом функции сохранить значения EAX, EBX, EDX
; аргументы передаются через регистры AX и BX
; первый аргумент размера word в AX - число
; второй аргумент размера word в BX - модуль
; возвращаемое значение размера word в AX
_do_mod:
    ; Как работает функция деления:
    ; div ДЕЛИТЕЛЬ
    ; AX = (DX AX) / ДЕЛИТЕЛЬ
    ; 
    ; Остаток от деления:
    ; В регистр DX

    ; (n%m + m) % m
    
    ; занулим dx
    xor dx, dx

    ; поделим: (DX AX) / BX, ответ запишется в AX, остаток от деления в DX
    div bx

    ; перемести остаток от деления из DX в AX
    mov ax, dx

    ; прибавим к остатку модуль
    add ax, bx

    ; снова обнулим dx
    xor dx, dx

    ; снова поделим: (DX AX) / BX, ответ запишется в AX, остаток от деления в DX
    div bx

    ; переместим остаток от деления и по совместительству ответ в ax
    mov ax, dx

    ret
; ------------------------------------------------------------------------------















; Блок кода, отвечающий за обработку ошибки при неправильной длинне ключа
_error_read_key_len:
    call _turn_canonical_echo_on
    jmp _end

; Блок кода, отвечающий за обработку любых других ошибок при считывании ключа
_error_read_key:
    call _turn_canonical_echo_on
    jmp _end

; Блок кода, обрабатывающий ошибку ввода не буквы в качестве символа ключа
_error_read_key_wrong_symbol:
    call _turn_canonical_echo_on
    jmp _end

; Блок кода, отвечающий за обработку ошибки открытия файла (любого)
_error_open_file:
    jmp _end

; Блок кода, отвечающий за обработку ошибки чтения файла (любого)
_error_read_file:
    jmp _end

; Блок кода, отвечающий за обработку ошибки записи в файл (в любой)
_error_write_file:
    jmp _end




























; ------------------------------------------------------------------------------
; Блок отвечающий за красивый ввод пароля, благодаря этому блоку
; при вводе пароля не будут видны символы, из которых он состоит,
; и вместо них будут выводиться звездочки.
; 
; Чтобы понять, как это происходит, нужно вспомнить, как делаются системные вызовы (стр. 6).
; Для того чтобы вызвать системную функцию (т.е. сделать системный вызов),
; мы должны сделать вызов ядра, при этом в регистре eax указать номер системного вызова
; (т.е. номер системной функции). 
; Напомню, ядро вызывается с помощью прерывания номер 80h (int 80h).
; Мы уже и раньше вызывали системные функции (например, 5 - для открытия файла и др.)
; 
; Теперь ближе к сути. По умолчанию, когда мы работаем в терминале, 
; он работает в так называемом каноническом режиме и еще в эхо-режиме.
; Канонический режим - значит, что данные, которые мы вводим во время работы в терминале, 
; не будут считаны до тех пор, пока не будет введена клавиша Enter. Это представляет проблему 
; при считывании пароля, т.к. мы бы хотели сразу же считывать введеный пользователем символ.
; Это помогло бы нам записывать вновь введеный пользователем символ в подготовленный буфер памяти и
; одновременно считать количество введенных пользователем символов, увеличивая длинну на 1 
; при вводе нового символа. 
; 
; Если бы мы попытались реализовать такую логику в каноническом режиме, то нам пришлось бы заставлять
; пользователя нажимать Enter каждый раз после ввода нового символа пароля, потому что, повторюсь,
; в каноническом режиме введеные символы не будут считаны до тех пор по не нажата клавиша Enter.
; А, соответственно, в неканоническом режиме символы считываются терминалом сразу же после их ввода,
; т.е. после нажатия на соответствующую клавишу, без необходимости нажимать после этого Enter.
; 
; Эхо-режим - такой режим, когда введенный пользователем сивол сразу же отображается на экране.
; Т.е., например, вы вводите 2, и на экране в тот же момент отображается 2.
; А мы хотим, чтобы вы вводили 2, а на экране ничего не появлялось, но на самом деле эта 2 должна также нормально 
; считаться терминалом, как и при эхо-режиме, вопрос только в отображении на экран. Почему при вводе 
; пароля это будет полезно, потому что вводимые символы не будут отображаться (это типо безопасно),
; а еще потому что в связке с неканоническим режимом при мгновенном считывании вводимых символов 
; (т.е. без необходимости нажимать Enter для каждого символа) мы в тот же момент можем выводить на экран, 
; например, звездочки вместо каждого введенного символа.
; 
; Именно поэтому мы и хотим отключить оба этих режима,
; НО ТОЛЬКО НА ВРЕМЯ ВВОДА ПАРОЛЯ.
; Т.е. после этого мы должны обратно включить оба этих режима,
; просто потому что так принято, что терминал по умолчанию работает в таких режимах. 
; 
; Теперь техническая часть вопроса. Вернемся к системным вызовам.
; Для настройки, в том числе, режимов работы термина используется системный вызов 
; (т.е. системная функция) 36h (ioctl - подробнее в инете).
; Эта функция принимает три аргумента:
; 1) файл, с которым работаем, в данном случае = 0, обозначающий стандартный поток ввода в терминале (STDIN);
; 2) число, обозначающее, что мы хотим сделать, в данном случае будем использовать всего два числа: 
;    5041h - для того, чтобы получить текущие настройки терминала и 5042h - для того, чтобы задать новые настройки;
; 3) указатель на область памяти, которая хранит структуру, которая будет содержать настройки терминала, 
;    ее размер 36 байт. Если мы задали второй аргумент = 5041h, то после вызова системной функции текущие настройки
;    терминала скопируются в эту область памяти. Если же задали 5042h, то после вызова системной функции, настройки
;    из этой области памяти скопируются и заменят собой текущие настройки терминала.
; 
; Структура выглядит так:
; struct termios {
;     tcflag_t c_iflag;               /* input mode flags */
;     tcflag_t c_oflag;               /* output mode flags */
;     tcflag_t c_cflag;               /* control mode flags */
;     tcflag_t c_lflag;               /* local mode flags */
;     cc_t     c_line;                /* line discipline */
;     cc_t     c_cc[NCCS];            /* control characters */
; };
; 
; Здесь тип tcflag_t - 4 байта, cc_t - 1 байт, NCCS=19. Итого 36 байт занимает 
; вся структура настроек терминала, называемая termios.
; 
; Нас интересует переменая c_lflag. Т.к. все переменные в структуре фактически 
; располагаются в памяти друг за другом, то c_lflag начинается с 12 байта (если вести отсчет с нуля).
; 
; В самом c_lflag за канонический режим отвечает первый бит 
; (если вести отсчет с нуля, давайте считать что дальше вездем ведем так отсчет),
; а за эхо-режим третий бит.
; 
; Т.е. вся суть работы сводится к:
; 1) мы получаем текущие настройки терминала (5041h);
; 2) меняем первый и третий биты четвертого байта структуры termios на нолики;
; 3) загружаем новые настройки (5042h);
; 4) вводим пароль;
; 5) снова получаем текущие настройки терминала (5041h);
; 6) меняем первый и третий биты четвертого байта структуры termios на единички, 
;    чтобы обратно включить канонический и эхо режимы.
; 
; Маленькое примечание: перед вызовами этих функций сохранить EAX, EBX, ECX, EDX

_turn_canonical_echo_off:
    call _read_stdin_termios
    mov eax, ICANON
    or eax, ECHO
    not eax
    and [termios + 12], eax
    call _write_stdin_termios
    ret
    

_turn_canonical_echo_on:
    call _read_stdin_termios
    mov eax, ICANON
    or eax, ECHO
    or [termios + 12], eax
    call _write_stdin_termios
    ret


_read_stdin_termios:
    mov eax, 36h
    mov ebx, 0
    mov ecx, 5401h
    mov edx, termios
    int 80h
    ret

_write_stdin_termios:
    mov eax, 36h
    mov ebx, 0
    mov ecx, 5402h
    mov edx, termios
    int 80h
    ret

; ------------------------------------------------------------------------------



















_end:
    mov eax, 1
    mov ebx, 0
    int 80h
; ------------------------------------------------------------------------------
























