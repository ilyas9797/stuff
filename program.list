     1                                  
     2                                  ; Метки объявленные с директивой global являются глобальными.
     3                                  ; Глобальные метки нужны она для возможности написания многомодульных программ.
     4                                  ; Благодаря ним другие модули могут, ссылаясь на эту метку,
     5                                  ; исполнять строки кода из данного модуля (стр. 17).
     6                                  ; В данном случае мы объявляем метку "_start" как глобальную.
     7                                  ; Это необходимо, чтобы компилятор знал, где начинается программа.
     8                                  global _start
     9                                  
    10                                  
    11                                  
    12                                  
    13                                  
    14                                  
    15                                  
    16                                  
    17                                  
    18                                  
    19                                  
    20                                  
    21                                  
    22                                  
    23                                  
    24                                  
    25                                  
    26                                  
    27                                  
    28                                  ; ------------------------------------------------------------------------------
    29                                  ; Секция статических данных (известных во время компиляции).
    30                                  ; В ней будут находить все данные известные до запуска программы,
    31                                  ; т.е. которые не будут изменяться во время работы программы.
    32                                  ; (подробнее стр. 9).
    33                                  section .data
    34                                  
    35                                  ; const_filename_plaintext содержит имя файла, из которого 
    36                                  ; будет происходить считывание открытого текста (подробнее о db на стр. 7).
    37 00000000 706C61696E74657874-     const_filename_plaintext db 'plaintext.txt', 0
    37 00000009 2E74787400         
    38                                  
    39                                  ; const_filename_encryptedtext содержит имя файла, в который 
    40                                  ; будет происходить запись шифртекста.
    41 0000000E 656E63727970746564-     const_filename_encryptedtext db 'encryptedtext.txt', 0
    41 00000017 746578742E74787400 
    42                                  
    43                                  ; const_filename_decryptedtext содержит имя файла, в который 
    44                                  ; будет происходить запись расшифрованного текста.
    45 00000020 646563727970746564-     const_filename_decryptedtext db 'decryptedtext.txt', 0
    45 00000029 746578742E74787400 
    46                                  
    47                                  ; const_message_for_user - сообщение пользователю, предлагающее ввести пароль
    48                                  ; число 10 обозначает переход на новую строку
    49 00000032 456E746572206B6579-     const_message_for_user db 'Enter key (up to 20 symbols):', 10
    49 0000003B 2028757020746F2032-
    49 00000044 302073796D626F6C73-
    49 0000004D 293A0A             
    50                                  
    51                                  ; const_len_message_for_user - хранит длинну сообщения для пользователя
    52                                  ; $ - равен текущему адресу
    53                                  const_len_message_for_user equ $ - const_message_for_user
    54                                  
    55 00000050 2A                      const_asterisk db '*'
    56                                  
    57                                  ICANON equ 1<<1
    58                                  ECHO equ 1<<3
    59                                  ; ------------------------------------------------------------------------------
    60                                  
    61                                  
    62                                  
    63                                  
    64                                  
    65                                  
    66                                  
    67                                  
    68                                  
    69                                  
    70                                  
    71                                  
    72                                  
    73                                  
    74                                  
    75                                  
    76                                  
    77                                  
    78                                  
    79                                  
    80                                  
    81                                  
    82                                  
    83                                  
    84                                  
    85                                  
    86                                  
    87                                  
    88                                  ; ------------------------------------------------------------------------------
    89                                  ; Секция динамических данных (так называемая куча).
    90                                  ; В ней будут находить все переменные, используемые и определяемые
    91                                  ; во время работы программы (подробнее стр. 9).
    92                                  section .bss
    93                                  
    94 00000000 <res 00000024>          termios resb 36
    95                                  
    96                                  ; val_buffer - переменная, указывающая на буфер для обработки данных.
    97                                  ; Принцип работы программы следующий:
    98                                  ; 1) Считываем до 4096 байтов текста из файла 'plaintext.txt'
    99                                  ;    в буфер val_buffer.
   100                                  ; 2) Шифруем текст в буфере.
   101                                  ; 3) Записываем шифртекст из буфера в файл 'encryptedtext.txt'.
   102                                  ; 4) Если на 1 шаге дошли до конца файла, то конец программы,
   103                                  ;    иначе возвращаемся к 1 шагу.
   104 00000024 <res 00001000>          val_buffer resb 4096
   105                                  
   106                                  ; val_key - хранит ключ, максимальная длина которого - 20 байт, минимальная допустимая - 1
   107 00001024 <res 00000015>          val_key resb 21
   108 00001039 <res 00000004>          val_len_key resb 4
   109                                  
   110                                  ; val_tmp - временный буфер, в него, например, будем сохранять 
   111                                  ; по одному символу при вводе пароля
   112 0000103D <res 00000002>          val_tmp resb 2
   113                                  
   114                                  ; val_ptr_file_plaintext - хранит указатель на файл с открытыми данными
   115 0000103F <res 00000004>          val_ptr_file_plaintext resb 4
   116                                  
   117                                  ; val_ptr_file_encryptedtext - хранит указатель на файл с зашифрованными данными
   118 00001043 <res 00000004>          val_ptr_file_encryptedtext resb 4
   119                                  
   120                                  ; val_ptr_file_decryptedtext - хранит указатель на файл с расшифрованными данными
   121 00001047 <res 00000004>          val_ptr_file_decryptedtext resb 4
   122                                  ; ------------------------------------------------------------------------------
   123                                  
   124                                  
   125                                  
   126                                  
   127                                  
   128                                  
   129                                  
   130                                  
   131                                  
   132                                  
   133                                  
   134                                  
   135                                  
   136                                  
   137                                  
   138                                  
   139                                  
   140                                  
   141                                  
   142                                  
   143                                  
   144                                  
   145                                  
   146                                  
   147                                  
   148                                  ; ------------------------------------------------------------------------------
   149                                  section .text
   150                                  
   151                                  ; Начало программы
   152                                  _start:
   153                                  
   154                                  ; открытие файла с открытым текстом в режиме чтения
   155                                  
   156                                  ; создание и открытие файла с зашифрованным текстом в режиме записи
   157                                  
   158                                  ; считывание ключа
   159 00000000 E80A000000              call _read_key
   160                                  
   161                                  ; чтение открытого тектса, его зашифрование и 
   162                                  ; запись зашифрованного текста в соответсвующий файл
   163 00000005 E8B4000000              call _encrypt_text
   164                                  
   165 0000000A E96D020000              jmp _end
   166                                  
   167                                  
   168                                  
   169                                  ; ------------------------------------------------------------------------------
   170                                  ; Функция, отвечающая за считывание ключа из командной строки
   171                                  ; Не принимает аргументов
   172                                  ; В случае успешного чтения ключа он будет записан в val_key, а в val_len_key его длинна
   173                                  _read_key:
   174                                  
   175                                  
   176                                      ; Вывод сообщения пользователю
   177                                      ; Подробнее о том как работают функции считывания и записи в файл на стр. 10
   178                                      ; 4 - обозначает функцию записи
   179                                      ; ssize_t write(int fd, const void *buf, size_t count)
   180 0000000F B804000000                  mov eax, 4
   181                                  
   182                                      ; В регистр ebx нужно положить первый аргумент для функции write - "int fd",
   183                                      ; а именно указатель на файл записи. В данном случае 1, т.к. это
   184                                      ; указывает на то, что запись будет будет производиться на дисплей
   185 00000014 BB01000000                  mov ebx, 1
   186                                  
   187                                      ; В регистр ecx кладем второй аргумент - буфер данных для записи
   188 00000019 B9[32000000]                mov ecx, const_message_for_user
   189                                  
   190                                      ; В edx кладем третий аргумент - количество записываемых символов
   191 0000001E BA1E000000                  mov edx, const_len_message_for_user
   192                                  
   193                                      ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
   194 00000023 CD80                        int 0x80
   195                                  
   196                                      ; Если при вызове функции произошла ошибка,
   197                                      ; то в регистре eax будет отрицательное число.
   198                                      ; Для проверки eax используем функцию test (подробнее стр. 8)
   199 00000025 85C0                        test eax, eax
   200                                      
   201                                      ; Если в eax появилось отрицательное число, то функция test установит 
   202                                      ; флаг sf в 1, и тогда сработает условный переход js, и программа 
   203                                      ; перейдет в блок обработки ошибки считывания ключа _error_read_key
   204                                      ; (подробнее об условных переходах стр. 4).
   205 00000027 0F88DB010000                js _error_read_key
   206                                  
   207 0000002D E8E8010000                  call _turn_canonical_echo_off
   208                                      
   209                                      ; обнуляем региср esi, он будет служить для хранения количества
   210                                      ; уже введеных пользователем символов
   211 00000032 31F6                        xor esi, esi
   212                                  
   213                                      ; цикл для считывания пароля
   214                                      _loop_read_key:
   215                                  
   216                                          ; если количество введеных символов станет больше 20,
   217                                          ; значит пользователь превысил максимальную длину пароля
   218 00000034 83FE14                          cmp esi, 20
   219 00000037 0F87C4010000                    ja _error_read_key_len
   220                                  
   221                                          ; Считывание пароля, будем считывать по 1 символу и 
   222                                          ; выводить звездочку на каждый символ
   223                                          ; 3 - обозначает функцию считывания
   224                                          ; ssize_t read(int fd, void *buf, size_t count)
   225 0000003D B803000000                      mov eax, 3
   226                                          
   227                                          ; В регистр ebx нужно положить первый аргумент для функции read - "int fd",
   228                                          ; а именно указатель на файл считывания. В данном случае 0, т.к. это
   229                                          ; указывает на то, что считывание будет происходить с клавиатруры
   230 00000042 BB00000000                      mov ebx, 0
   231                                          
   232                                          ; В регистр ecx кладем второй аргумент - буфер для считанных данных
   233 00000047 B9[3D100000]                    mov ecx, val_tmp
   234                                          
   235                                          ; В edx кладем третий аргумент - количество считываемых символов
   236 0000004C BA01000000                      mov edx, 1
   237                                          
   238                                          ; Вызываем указанную функцию с указанными параметрами (подробнее стр. 6)
   239 00000051 CD80                            int 80h
   240                                          
   241 00000053 85C0                            test eax, eax
   242 00000055 0F88AD010000                    js _error_read_key
   243                                  
   244 0000005B A0[3D100000]                    mov al, byte [val_tmp]
   245                                          ; проверка того, что пользователь ввел Enter (символ перехода на новую строку)
   246 00000060 3C0A                            cmp al, 10
   247 00000062 7445                            je _end_loop_read_key
   248                                  
   249                                          ; если пользователь ввел не Enter, то записываем символ в буфер,
   250                                          ; причем записываем вес символа, т.е для буквы a (A) - это 1, для b (B) - это 2 и т.д.
   251                                          ; Также нужно проверить, что введена именно буква
   252                                          ; является ли текущий символ маленькой буквой
   253                                          ; 97 <= al <= 122
   254 00000064 3C61                            cmp al, 97
   255 00000066 7208                            jb _read_key_check_next
   256 00000068 3C7A                            cmp al, 122
   257 0000006A 7704                            ja _read_key_check_next
   258 0000006C 2C61                            sub al, 97
   259 0000006E EB12                            jmp _read_key_check_end
   260                                  
   261                                  
   262                                          _read_key_check_next:
   263                                          ; является ли текущий символ большой буквой
   264                                          ; 65 <= al <= 90
   265 00000070 3C41                            cmp al, 65
   266 00000072 0F8297010000                    jb _error_read_key_wrong_symbol
   267 00000078 3C5A                            cmp al, 90
   268 0000007A 0F878F010000                    ja _error_read_key_wrong_symbol
   269 00000080 2C41                            sub al, 65
   270                                  
   271                                          _read_key_check_end:
   272                                  
   273 00000082 8886[24100000]                  mov byte [val_key + esi], al
   274                                  
   275                                          ; Вывод звездочки на экран
   276 00000088 B804000000                      mov eax, 4
   277 0000008D BB01000000                      mov ebx, 1
   278 00000092 B9[50000000]                    mov ecx, const_asterisk
   279 00000097 BA01000000                      mov edx, 1
   280 0000009C CD80                            int 80h
   281                                  
   282                                          ; ошибка при выводе звездочки
   283 0000009E 85C0                            test eax, eax
   284 000000A0 0F8862010000                    js _error_read_key
   285                                  
   286                                          ; увеличиваем текущую длинну пароля
   287 000000A6 46                              inc esi
   288                                  
   289 000000A7 EB8B                            jmp _loop_read_key
   290                                  
   291                                      ; конец цикла считывания ключа
   292                                      _end_loop_read_key:
   293                                  
   294                                      ; проверка на то, что пользователь не ввел ни одного символа и нажал Enter
   295 000000A9 83FE00                      cmp esi, 0
   296 000000AC 0F844F010000                je _error_read_key_len
   297                                  
   298                                      ; сохраняем длинну ключа в переменную val_len_key
   299 000000B2 8935[39100000]              mov dword [val_len_key], esi
   300                                  
   301 000000B8 E878010000                  call _turn_canonical_echo_on
   302                                  
   303 000000BD C3                          ret
   304                                  
   305                                  ; ------------------------------------------------------------------------------
   306                                  
   307                                  
   308                                  
   309                                  
   310                                  
   311                                  
   312                                  
   313                                  
   314                                  
   315                                  
   316                                  
   317                                  
   318                                  
   319                                  
   320                                  
   321                                  
   322                                  
   323                                  
   324                                  
   325                                  
   326                                  
   327                                  
   328                                  
   329                                  ; ------------------------------------------------------------------------------
   330                                  ; Функция шифрования текта. Общий принцип работы следующий:
   331                                  ; 1) Считывание до 4096 байтов из файла const_filename_plaintext с открытым текстом в буфер val_buffer
   332                                  ; 2) Шифрование данных в буфере val_buffer ключем из val_key
   333                                  ; 3) Запись зашифрованных данных в файл const_filename_encryptedtext
   334                                  ; 4) Если остались несчитанные данные в файле const_filename_plaintext, возврат к пункту 1
   335                                  _encrypt_text:
   336                                  
   337                                      ; открытие файла c открытым текстом с именем const_filename_plaintext в режиме чтения
   338 000000BE B805000000                  mov eax, 5
   339 000000C3 BB[00000000]                mov ebx, const_filename_plaintext
   340 000000C8 B900000000                  mov ecx, 0
   341 000000CD CD80                        int 80h
   342 000000CF 85C0                        test eax, eax
   343 000000D1 0F883F010000                js _error_open_file
   344                                  
   345                                      ; сохраняем дескриптор файла c открытым текстом
   346 000000D7 A3[3F100000]                mov dword [val_ptr_file_plaintext], eax
   347                                  
   348                                      ; открытие файла c зашифрованным текстом с именем const_filename_encryptedtext в режиме создания и записи
   349 000000DC B805000000                  mov eax, 5
   350 000000E1 BB[0E000000]                mov ebx, const_filename_encryptedtext
   351 000000E6 B941000000                  mov ecx, 101q
   352 000000EB BAC0010000                  mov edx, 700q
   353 000000F0 CD80                        int 80h
   354 000000F2 85C0                        test eax, eax
   355 000000F4 0F881C010000                js _error_open_file
   356                                  
   357                                      ; сохраняем дескриптор файла c зашифрованным текстом
   358 000000FA A3[43100000]                mov dword [val_ptr_file_encryptedtext], eax
   359                                  
   360                                      ; будем используем для хранения текущего символа ключа
   361 000000FF 31F6                        xor esi, esi
   362                                  
   363                                  
   364                                      ; цикл, для считывания файла с открытым текстом порционно по 4096 байтов
   365                                      _loop_read_plaintext_file:
   366                                  
   367                                          ; чтение до 4096 байтов из файла с открытым текстом 
   368 00000101 B803000000                      mov eax, 3
   369 00000106 8B1D[3F100000]                  mov ebx, dword [val_ptr_file_plaintext]
   370 0000010C B9[24000000]                    mov ecx, val_buffer
   371 00000111 BA00100000                      mov edx, 4096
   372 00000116 CD80                            int 80h
   373                                  
   374                                          ; Проверяем, что функция read отработала без ошибки,
   375                                          ; т.е. проверяем положительное или отрицательное число лежит в eax
   376 00000118 85C0                            test eax, eax
   377 0000011A 0F88E8000000                    js _error_read_key
   378                                  
   379                                          ; если не было считано ни одного символа, значит достигли конца файла, и выходим из цикла
   380 00000120 83F800                          cmp eax, 0
   381 00000123 0F8490000000                    je _end_loop_read_plaintext_file
   382                                  
   383                                          ; используем команду loop и регистр ecx для организации цикла (подробнее стр. 5)
   384                                          ; eax будет также хранить ориинальное количество считанных символов
   385 00000129 89C1                            mov ecx, eax
   386                                  
   387                                          ; цикл, который зашифровывает побайтово буфер со считанным текстом val_buffer согласно следующему правилу:
   388                                          ; 1) если символ - буква (неважно какой регистр) или цифра то шифруем (типо с учетом весов)
   389                                          ; 2) иначе пропускаем, причем в этом случае все равно переходим к следующему символу ключа (пусть будет так)
   390                                          ; В цикле нельзя использовать регистр ecx - отвечает за работу цикла (подробнее стр. 5),
   391                                          ; eax - будет хранит длинну считанного текста (можно сохранять перед использованием, а потом восстановливать)
   392                                          _loop_encrypt_buffer:
   393                                  
   394                                              ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   395                                              ; определяем текущий символ ключа по формуле
   396                                              ; esi % val_len_key
   397                                              
   398                                              ; сохраним значение eax, чтобы не потерять длину считанного блока
   399 0000012B 50                                  push eax
   400                                  
   401                                              ; вычислим номер символа ключа, с помощью которого шифруется текущий символ текста
   402                                              ; при взятии значения регистра esi по модулю val_len_key будем рассматривать 
   403                                              ; только младшую часть регистра esi, т.е. si, потому что, напомню, максимальная длина
   404                                              ; ключа может быть 20 символов и это значение будет занимать точно меньше 16 бит, 
   405                                              ; поэтому, очевидно, что будет умещаться в младшей половине регистра esi (напомню, 
   406                                              ; длина регистра esi - 32 бита)
   407                                              ; можно не волноваться за переполнение ax и bx,
   408                                              ; т.к. максимальная длина ключа точно меньше 16 бит
   409 0000012C 6689F0                              mov ax, si
   410 0000012F 668B1D[39100000]                    mov bx, word [val_len_key]
   411 00000136 E8B0000000                          call _do_mod
   412 0000013B 6689C6                              mov si, ax
   413                                  
   414                                              ; восстановим значение eax
   415 0000013E 58                                  pop eax
   416                                              ; определили текущий символ ключа
   417                                              ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   418                                  
   419                                  
   420                                  
   421                                  
   422                                              ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   423                                              ; начало шифрования
   424                                              ; проверка что символ - буква
   425                                              ; а иначе пропуск блока шифрования
   426                                  
   427 0000013F 50                                  push eax
   428                                  
   429 00000140 31D2                                xor edx, edx
   430                                              ; переместим рассматриваемый символ (байт) в bl
   431                                              
   432 00000142 31DB                                xor ebx, ebx
   433 00000144 31FF                                xor edi, edi
   434 00000146 6689C7                              mov di, ax
   435 00000149 6629CF                              sub di, cx
   436 0000014C 8A9F[24000000]                      mov bl, byte [val_buffer + edi]
   437                                              
   438                                              ; является ли текущий символ маленькой буквой
   439                                              ; 97 <= bx <= 122
   440 00000152 80FB61                              cmp bl, 97
   441 00000155 7214                                jb _check_enc_next
   442 00000157 80FB7A                              cmp bl, 122
   443 0000015A 770F                                ja _check_enc_next
   444 0000015C 8A96[24100000]                      mov dl, byte [val_key + esi]
   445 00000162 B061                                mov al, 97
   446 00000164 E86B000000                          call _do_encrypt
   447 00000169 EB17                                jmp _check_enc_end
   448                                  
   449                                  
   450                                  
   451                                              _check_enc_next:
   452                                              ; является ли текущий символ большой буквой
   453                                              ; 65 <= bx <= 90
   454 0000016B 80FB41                              cmp bl, 65
   455 0000016E 7212                                jb _check_enc_end
   456 00000170 80FB5A                              cmp bl, 90
   457 00000173 770D                                ja _check_enc_end
   458 00000175 8A96[24100000]                      mov dl, byte [val_key + esi]
   459 0000017B B041                                mov al, 65
   460 0000017D E852000000                          call _do_encrypt
   461                                  
   462                                              _check_enc_end:
   463 00000182 58                                  pop eax
   464                                              ; конец шифрования
   465                                              ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   466                                  
   467                                              ; теперь в bl лежит зашифрованный символ (ну или незашифрованный, 
   468                                              ; а тот же самый, если символ не был буквой)
   469                                              ; перезапишем его в буфер
   470 00000183 31FF                                xor edi, edi
   471 00000185 6689C7                              mov di, ax
   472 00000188 6629CF                              sub di, cx
   473 0000018B 889F[24000000]                      mov byte [val_buffer + edi], bl
   474                                              
   475                                  
   476                                              ; возьмем следующий символ ключа
   477 00000191 46                                  inc esi
   478                                  
   479 00000192 E297                            loop _loop_encrypt_buffer
   480                                  
   481                                          ; теперь в буфере храниться зашифрованное сообщение
   482                                          ; запишем его в файл с зашифрованным сообщением const_filename_encryptedtext
   483 00000194 50                              push eax
   484                                          ; количество зашифрованных символов
   485 00000195 89C2                            mov edx, eax
   486                                          ; операция записи
   487 00000197 B804000000                      mov eax, 4
   488                                          ; дескриптор файла с зашифрованным текстом
   489 0000019C 8B1D[43100000]                  mov ebx, dword [val_ptr_file_encryptedtext]
   490                                          ; указатель на буфер с зашифрованным текстом
   491 000001A2 B9[24000000]                    mov ecx, val_buffer
   492 000001A7 CD80                            int 80h
   493 000001A9 85C0                            test eax, eax
   494 000001AB 786B                            js _error_write_file
   495                                  
   496 000001AD 58                              pop eax
   497                                          
   498                                  
   499                                  
   500                                          ; если на этой итерации цикла мы считали 4096 байтов текста,
   501                                          ; значит, возможно в файле остались еще несчитанные символы
   502 000001AE 3D00100000                      cmp eax, 4096
   503 000001B3 0F8448FFFFFF                    je _loop_read_plaintext_file
   504                                  
   505                                          
   506                                  
   507                                      _end_loop_read_plaintext_file:
   508                                  
   509                                      ; закончили работать с файлами, теперь их можно закрыть
   510 000001B9 B806000000                  mov eax, 6
   511 000001BE 8B1D[43100000]              mov ebx, dword [val_ptr_file_encryptedtext]
   512 000001C4 CD80                        int 80h
   513                                  
   514 000001C6 B806000000                  mov eax, 6
   515 000001CB 8B1D[3F100000]              mov ebx, dword [val_ptr_file_plaintext]
   516 000001D1 CD80                        int 80h
   517                                      
   518                                  
   519 000001D3 C3                          ret
   520                                  ; ------------------------------------------------------------------------------
   521                                  
   522                                  
   523                                  
   524                                  
   525                                  
   526                                  
   527                                  
   528                                  
   529                                  
   530                                  
   531                                  
   532                                  
   533                                  ; ------------------------------------------------------------------------------
   534                                  ; Функция шифрует символ текста символом ключа
   535                                  ; перед вызовом функции сохранить значения EAX, EBX, EDX
   536                                  ; Входные аргументы:
   537                                  ; BL - шифруемый символ
   538                                  ; DL - вес символа ключа
   539                                  ; AL - смещение в таблице ascii
   540                                  ; Возвращаемое значение:
   541                                  ; BL - зашифрованный символ
   542                                  _do_encrypt:
   543                                  
   544                                  
   545                                      ; вычисляем вес символа текста
   546 000001D4 28C3                        sub bl, al
   547                                      
   548                                      ; складываем символ текста с символом ключа
   549 000001D6 00D3                        add bl, dl
   550                                  
   551 000001D8 50                          push eax
   552                                      ; возьмем сложенное значение по модулю 26, именно столько букв в англ алфавите
   553 000001D9 6689D8                      mov ax, bx
   554 000001DC 66BB1A00                    mov bx, 26
   555 000001E0 E806000000                  call _do_mod
   556                                  
   557                                      ; вернем полученное значение в BL
   558 000001E5 88C3                        mov bl, al
   559 000001E7 58                          pop eax
   560 000001E8 00C3                        add bl, al
   561                                  
   562 000001EA C3                          ret
   563                                  ; ------------------------------------------------------------------------------
   564                                  
   565                                  
   566                                  
   567                                  
   568                                  
   569                                  
   570                                  
   571                                  
   572                                  
   573                                  
   574                                  
   575                                  
   576                                  
   577                                  
   578                                  ; ------------------------------------------------------------------------------
   579                                  ; Функция взятие числа по модулю
   580                                  ; перед вызовом функции сохранить значения EAX, EBX, EDX
   581                                  ; аргументы передаются через регистры AX и BX
   582                                  ; первый аргумент размера word в AX - число
   583                                  ; второй аргумент размера word в BX - модуль
   584                                  ; возвращаемое значение размера word в AX
   585                                  _do_mod:
   586                                      ; Как работает функция деления:
   587                                      ; div ДЕЛИТЕЛЬ
   588                                      ; AX = (DX AX) / ДЕЛИТЕЛЬ
   589                                      ; 
   590                                      ; Остаток от деления:
   591                                      ; В регистр DX
   592                                  
   593                                      ; (n%m + m) % m
   594                                      
   595                                      ; занулим dx
   596 000001EB 6631D2                      xor dx, dx
   597                                  
   598                                      ; поделим: (DX AX) / BX, ответ запишется в AX, остаток от деления в DX
   599 000001EE 66F7F3                      div bx
   600                                  
   601                                      ; перемести остаток от деления из DX в AX
   602 000001F1 6689D0                      mov ax, dx
   603                                  
   604                                      ; прибавим к остатку модуль
   605 000001F4 6601D8                      add ax, bx
   606                                  
   607                                      ; снова обнулим dx
   608 000001F7 6631D2                      xor dx, dx
   609                                  
   610                                      ; снова поделим: (DX AX) / BX, ответ запишется в AX, остаток от деления в DX
   611 000001FA 66F7F3                      div bx
   612                                  
   613                                      ; переместим остаток от деления и по совместительству ответ в ax
   614 000001FD 6689D0                      mov ax, dx
   615                                  
   616 00000200 C3                          ret
   617                                  ; ------------------------------------------------------------------------------
   618                                  
   619                                  
   620                                  
   621                                  
   622                                  
   623                                  
   624                                  
   625                                  
   626                                  
   627                                  
   628                                  
   629                                  
   630                                  
   631                                  
   632                                  
   633                                  ; Блок кода, отвечающий за обработку ошибки при неправильной длинне ключа
   634                                  _error_read_key_len:
   635 00000201 E82F000000                  call _turn_canonical_echo_on
   636 00000206 EB74                        jmp _end
   637                                  
   638                                  ; Блок кода, отвечающий за обработку любых других ошибок при считывании ключа
   639                                  _error_read_key:
   640 00000208 E828000000                  call _turn_canonical_echo_on
   641 0000020D EB6D                        jmp _end
   642                                  
   643                                  ; Блок кода, обрабатывающий ошибку ввода не буквы в качестве символа ключа
   644                                  _error_read_key_wrong_symbol:
   645 0000020F E821000000                  call _turn_canonical_echo_on
   646 00000214 EB66                        jmp _end
   647                                  
   648                                  ; Блок кода, отвечающий за обработку ошибки открытия файла (любого)
   649                                  _error_open_file:
   650 00000216 EB64                        jmp _end
   651                                  
   652                                  ; Блок кода, отвечающий за обработку ошибки записи в файл (в любой)
   653                                  _error_write_file:
   654 00000218 EB62                        jmp _end
   655                                  
   656                                  
   657                                  
   658                                  
   659                                  
   660                                  
   661                                  
   662                                  
   663                                  
   664                                  
   665                                  
   666                                  
   667                                  
   668                                  
   669                                  
   670                                  
   671                                  
   672                                  
   673                                  
   674                                  
   675                                  
   676                                  
   677                                  
   678                                  
   679                                  
   680                                  
   681                                  
   682                                  
   683                                  ; ------------------------------------------------------------------------------
   684                                  ; Блок отвечающий за красивый ввод пароля, благодаря этому блоку
   685                                  ; при вводе пароля не будут видны символы, из которых он состоит,
   686                                  ; и вместо них будут выводиться звездочки.
   687                                  ; 
   688                                  ; Чтобы понять, как это происходит, нужно вспомнить, как делаются системные вызовы (стр. 6).
   689                                  ; Для того чтобы вызвать системную функцию (т.е. сделать системный вызов),
   690                                  ; мы должны сделать вызов ядра, при этом в регистре eax указать номер системного вызова
   691                                  ; (т.е. номер системной функции). 
   692                                  ; Напомню, ядро вызывается с помощью прерывания номер 80h (int 80h).
   693                                  ; Мы уже и раньше вызывали системные функции (например, 5 - для открытия файла и др.)
   694                                  ; 
   695                                  ; Теперь ближе к сути. По умолчанию, когда мы работаем в терминале, 
   696                                  ; он работает в так называемом каноническом режиме и еще в эхо-режиме.
   697                                  ; Канонический режим - значит, что данные, которые мы вводим во время работы в терминале, 
   698                                  ; не будут считаны до тех пор, пока не будет введена клавиша Enter. Это представляет проблему 
   699                                  ; при считывании пароля, т.к. мы бы хотели сразу же считывать введеный пользователем символ.
   700                                  ; Это помогло бы нам записывать вновь введеный пользователем символ в подготовленный буфер памяти и
   701                                  ; одновременно считать количество введенных пользователем символов, увеличивая длинну на 1 
   702                                  ; при вводе нового символа. 
   703                                  ; 
   704                                  ; Если бы мы попытались реализовать такую логику в каноническом режиме, то нам пришлось бы заставлять
   705                                  ; пользователя нажимать Enter каждый раз после ввода нового символа пароля, потому что, повторюсь,
   706                                  ; в каноническом режиме введеные символы не будут считаны до тех пор по не нажата клавиша Enter.
   707                                  ; А, соответственно, в неканоническом режиме символы считываются терминалом сразу же после их ввода,
   708                                  ; т.е. после нажатия на соответствующую клавишу, без необходимости нажимать после этого Enter.
   709                                  ; 
   710                                  ; Эхо-режим - такой режим, когда введенный пользователем сивол сразу же отображается на экране.
   711                                  ; Т.е., например, вы вводите 2, и на экране в тот же момент отображается 2.
   712                                  ; А мы хотим, чтобы вы вводили 2, а на экране ничего не появлялось, но на самом деле эта 2 должна также нормально 
   713                                  ; считаться терминалом, как и при эхо-режиме, вопрос только в отображении на экран. Почему при вводе 
   714                                  ; пароля это будет полезно, потому что вводимые символы не будут отображаться (это типо безопасно),
   715                                  ; а еще потому что в связке с неканоническим режимом при мгновенном считывании вводимых символов 
   716                                  ; (т.е. без необходимости нажимать Enter для каждого символа) мы в тот же момент можем выводить на экран, 
   717                                  ; например, звездочки вместо каждого введенного символа.
   718                                  ; 
   719                                  ; Именно поэтому мы и хотим отключить оба этих режима,
   720                                  ; НО ТОЛЬКО НА ВРЕМЯ ВВОДА ПАРОЛЯ.
   721                                  ; Т.е. после этого мы должны обратно включить оба этих режима,
   722                                  ; просто потому что так принято, что терминал по умолчанию работает в таких режимах. 
   723                                  ; 
   724                                  ; Теперь техническая часть вопроса. Вернемся к системным вызовам.
   725                                  ; Для настройки, в том числе, режимов работы термина используется системный вызов 
   726                                  ; (т.е. системная функция) 36h (ioctl - подробнее в инете).
   727                                  ; Эта функция принимает три аргумента:
   728                                  ; 1) файл, с которым работаем, в данном случае = 0, обозначающий стандартный поток ввода в терминале (STDIN);
   729                                  ; 2) число, обозначающее, что мы хотим сделать, в данном случае будем использовать всего два числа: 
   730                                  ;    5041h - для того, чтобы получить текущие настройки терминала и 5042h - для того, чтобы задать новые настройки;
   731                                  ; 3) указатель на область памяти, которая хранит структуру, которая будет содержать настройки терминала, 
   732                                  ;    ее размер 36 байт. Если мы задали второй аргумент = 5041h, то после вызова системной функции текущие настройки
   733                                  ;    терминала скопируются в эту область памяти. Если же задали 5042h, то после вызова системной функции, настройки
   734                                  ;    из этой области памяти скопируются и заменят собой текущие настройки терминала.
   735                                  ; 
   736                                  ; Структура выглядит так:
   737                                  ; struct termios {
   738                                  ;     tcflag_t c_iflag;               /* input mode flags */
   739                                  ;     tcflag_t c_oflag;               /* output mode flags */
   740                                  ;     tcflag_t c_cflag;               /* control mode flags */
   741                                  ;     tcflag_t c_lflag;               /* local mode flags */
   742                                  ;     cc_t     c_line;                /* line discipline */
   743                                  ;     cc_t     c_cc[NCCS];            /* control characters */
   744                                  ; };
   745                                  ; 
   746                                  ; Здесь тип tcflag_t - 4 байта, cc_t - 1 байт, NCCS=19. Итого 36 байт занимает 
   747                                  ; вся структура настроек терминала, называемая termios.
   748                                  ; 
   749                                  ; Нас интересует переменая c_lflag. Т.к. все переменные в структуре фактически 
   750                                  ; располагаются в памяти друг за другом, то c_lflag начинается с 12 байта (если вести отсчет с нуля).
   751                                  ; 
   752                                  ; В самом c_lflag за канонический режим отвечает первый бит 
   753                                  ; (если вести отсчет с нуля, давайте считать что дальше вездем ведем так отсчет),
   754                                  ; а за эхо-режим третий бит.
   755                                  ; 
   756                                  ; Т.е. вся суть работы сводится к:
   757                                  ; 1) мы получаем текущие настройки терминала (5041h);
   758                                  ; 2) меняем первый и третий биты четвертого байта структуры termios на нолики;
   759                                  ; 3) загружаем новые настройки (5042h);
   760                                  ; 4) вводим пароль;
   761                                  ; 5) снова получаем текущие настройки терминала (5041h);
   762                                  ; 6) меняем первый и третий биты четвертого байта структуры termios на единички, 
   763                                  ;    чтобы обратно включить канонический и эхо режимы.
   764                                  ; 
   765                                  ; Маленькое примечание: перед вызовами этих функций сохранить EAX, EBX, ECX, EDX
   766                                  
   767                                  _turn_canonical_echo_off:
   768 0000021A E82F000000                  call _read_stdin_termios
   769 0000021F B802000000                  mov eax, ICANON
   770 00000224 83C808                      or eax, ECHO
   771 00000227 F7D0                        not eax
   772 00000229 2105[0C000000]              and [termios + 12], eax
   773 0000022F E831000000                  call _write_stdin_termios
   774 00000234 C3                          ret
   775                                      
   776                                  
   777                                  _turn_canonical_echo_on:
   778 00000235 E814000000                  call _read_stdin_termios
   779 0000023A B802000000                  mov eax, ICANON
   780 0000023F 83C808                      or eax, ECHO
   781 00000242 0905[0C000000]              or [termios + 12], eax
   782 00000248 E818000000                  call _write_stdin_termios
   783 0000024D C3                          ret
   784                                  
   785                                  
   786                                  _read_stdin_termios:
   787 0000024E B836000000                  mov eax, 36h
   788 00000253 BB00000000                  mov ebx, 0
   789 00000258 B901540000                  mov ecx, 5401h
   790 0000025D BA[00000000]                mov edx, termios
   791 00000262 CD80                        int 80h
   792 00000264 C3                          ret
   793                                  
   794                                  _write_stdin_termios:
   795 00000265 B836000000                  mov eax, 36h
   796 0000026A BB00000000                  mov ebx, 0
   797 0000026F B902540000                  mov ecx, 5402h
   798 00000274 BA[00000000]                mov edx, termios
   799 00000279 CD80                        int 80h
   800 0000027B C3                          ret
   801                                  
   802                                  ; ------------------------------------------------------------------------------
   803                                  
   804                                  
   805                                  
   806                                  
   807                                  
   808                                  
   809                                  
   810                                  
   811                                  
   812                                  
   813                                  
   814                                  
   815                                  
   816                                  
   817                                  
   818                                  
   819                                  
   820                                  
   821                                  
   822                                  _end:
   823 0000027C B801000000                  mov eax, 1
   824 00000281 BB00000000                  mov ebx, 0
   825 00000286 CD80                        int 80h
   826                                  ; ------------------------------------------------------------------------------
   827                                  
   828                                  
   829                                  
   830                                  
   831                                  
   832                                  
   833                                  
   834                                  
   835                                  
   836                                  
   837                                  
   838                                  
   839                                  
   840                                  
   841                                  
   842                                  
   843                                  
   844                                  
   845                                  
   846                                  
   847                                  
   848                                  
   849                                  
   850                                  
